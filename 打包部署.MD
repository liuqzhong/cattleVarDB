# CattleVarDB Docker 打包部署指南

本文档介绍如何将前后端分离的 CattleVarDB 项目使用 Docker 部署到 Linux 服务器上。

## 项目架构

```
cattleVarDB/
├── backend/           # FastAPI 后端
│   ├── Dockerfile
│   └── requirements.txt
├── frontend/          # Vue 3 前端
│   ├── Dockerfile
│   ├── nginx.conf
│   └── package.json
├── database/          # 数据库脚本
│   └── schema.sql
├── SNP-disease/       # 数据文件
├── docker-compose.yml # Docker 编排配置
└── 打包部署.MD        # 本文档
```

## 配置修改说明

### 问题分析

原始配置存在以下问题：

1. 前端使用 `VITE_API_BASE_URL: http://localhost:8000`，在 Docker 环境中 `localhost` 指向前端容器自己，无法访问后端
2. nginx 只配置了 `/api/` 路径的代理，但前端实际调用的是 `/snps`、`/targets`、`/stats`、`/health` 等路径

### 解决方案

#### 1. 修改 `frontend/nginx.conf`

添加后端 API 的完整代理配置：

```nginx
# Backend API proxy for all API endpoints
location /snps/ {
    proxy_pass http://backend:8000/snps/;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

location /targets/ {
    proxy_pass http://backend:8000/targets/;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

location /stats {
    proxy_pass http://backend:8000/stats;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

location /health {
    proxy_pass http://backend:8000/health;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}
```

#### 2. 修改 `docker-compose.yml`

将 `VITE_API_BASE_URL` 从运行时环境变量改为构建参数，设为空字符串使用相对路径：

```yaml
frontend:
  build:
    context: ./frontend
    dockerfile: Dockerfile
    args:
      VITE_API_BASE_URL: ""
  container_name: cattle_snp_frontend
  restart: unless-stopped
  ports:
    - "80:80"
```

#### 3. 修改 `frontend/Dockerfile`

添加构建参数支持：

```dockerfile
# Build stage
FROM node:20-alpine AS builder

# Build arguments for environment variables
ARG VITE_API_BASE_URL

WORKDIR /app

# Copy package files
COPY package.json ./

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Build application with environment variable
ENV VITE_API_BASE_URL=${VITE_API_BASE_URL}
RUN npm run build

# Production stage
FROM nginx:alpine
...
```

## Linux 服务器部署步骤

### 1. 准备服务器

确保服务器已安装：

```bash
# 检查版本
docker --version          # 需要 20.10+
docker compose version    # 需要 2.0+
```

如未安装，执行：

```bash
# 安装 Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# 启动 Docker
sudo systemctl start docker
sudo systemctl enable docker

# 添加当前用户到 docker 组（可选）
sudo usermod -aG docker $USER
```

### 2. 上传项目文件到服务器

#### 方法一：使用 scp

```bash
# 在本地打包（排除不必要的文件）
tar -czf cattleVarDB.tar.gz --exclude='node_modules' --exclude='__pycache__' --exclude='*.pyc' --exclude='.git' .

# 上传到服务器
scp cattleVarDB.tar.gz user@your-server:/opt/

# 在服务器上解压
ssh user@your-server
cd /opt
mkdir -p cattleVarDB
tar -xzf cattleVarDB.tar.gz -C cattleVarDB
cd cattleVarDB
```

#### 方法二：使用 git

```bash
# 如果项目在 git 仓库中
git clone <your-repo-url> /opt/cattleVarDB
cd /opt/cattleVarDB
```

#### 方法三：使用 rsync

```bash
# 同步文件到服务器
rsync -av --exclude='node_modules' \
          --exclude='__pycache__' \
          --exclude='*.pyc' \
          --exclude='.git' \
          ./ user@your-server:/opt/cattleVarDB/
```

### 3. 修改端口映射（可选）

如果服务器上 80 或 5432 端口被占用，修改 `docker-compose.yml`：

```yaml
services:
  db:
    # ...
    ports:
      - "15432:5432"  # 数据库端口改为 15432

  frontend:
    # ...
    ports:
      - "8080:80"  # 前端端口改为 8080
```

### 4. 启动服务

```bash
# 构建并启动所有服务
docker compose up -d --build

# 查看启动状态
docker compose ps

# 查看日志
docker compose logs -f
```

预期输出：

```
NAME                  IMAGE                              STATUS
cattle_var_db         postgres:15-alpine                Up (healthy)
cattle_snp_backend    cattlevardb-backend:latest         Up (healthy)
cattle_snp_frontend   cattlevardb-frontend:latest        Up (healthy)
```

### 5. 数据导入（首次部署）

```bash
# 导入 SNP-disease 数据
docker compose --profile import up data-import

# 查看导入日志
docker compose logs data-import
```

### 6. 验证部署

```bash
# 检查后端健康状态
curl http://localhost/health

# 预期响应: {"status":"healthy"}

# 检查数据库统计
curl http://localhost/stats

# 访问前端
# 浏览器打开: http://your-server-ip
```

## 常用管理命令

### 服务管理

```bash
# 停止服务
docker compose down

# 重启服务
docker compose restart

# 重启单个服务
docker compose restart backend

# 查看服务状态
docker compose ps

# 查看资源使用
docker stats
```

### 日志查看

```bash
# 查看所有服务日志
docker compose logs -f

# 查看特定服务日志
docker compose logs -f backend
docker compose logs -f frontend
docker compose logs -f db

# 查看最近 100 行日志
docker compose logs --tail=100 backend
```

### 数据库管理

```bash
# 进入数据库容器
docker exec -it cattle_var_db psql -U cattle_user -d cattle_snp_db

# 备份数据库
docker exec cattle_var_db pg_dump -U cattle_user cattle_snp_db > backup.sql

# 恢复数据库
docker exec -i cattle_var_db psql -U cattle_user cattle_snp_db < backup.sql

# 导出为压缩备份
docker exec cattle_var_db pg_dump -U cattle_user cattle_snp_db | gzip > backup_$(date +%Y%m%d).sql.gz

# 恢复压缩备份
gunzip -c backup_20240115.sql.gz | docker exec -i cattle_var_db psql -U cattle_user cattle_snp_db
```

### 进入容器

```bash
# 进入后端容器
docker exec -it cattle_snp_backend bash

# 进入前端容器
docker exec -it cattle_snp_frontend sh

# 进入数据库容器
docker exec -it cattle_var_db sh
```

## 服务访问地址

| 服务 | 内部地址 | 外部访问地址 |
|------|----------|--------------|
| 前端 | http://frontend:80 | http://your-server-ip:80 |
| 后端 | http://backend:8000 | 通过 nginx 代理访问 |
| 数据库 | db:5432 | localhost:5432 (需在 docker-compose.yml 中配置) |

## 防火墙配置

```bash
# Ubuntu/Debian
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# CentOS/RHEL
sudo firewall-cmd --permanent --add-port=80/tcp
sudo firewall-cmd --permanent --add-port=443/tcp
sudo firewall-cmd --reload
```

## 常见问题排查

### 容器无法启动

```bash
# 查看容器日志
docker compose logs backend
docker compose logs frontend
docker compose logs db

# 检查容器状态
docker compose ps -a
```

### 数据库连接失败

```bash
# 检查数据库是否健康
docker exec cattle_var_db pg_isready -U cattle_user -d cattle_snp_db

# 检查网络连接
docker compose exec backend ping db
```

### 前端无法访问后端 API

1. 确认 nginx.conf 中的代理配置正确
2. 确认 docker-compose.yml 中 `VITE_API_BASE_URL` 已移到 `build.args`
3. 重新构建前端镜像：`docker compose up -d --build frontend`

### 数据导入失败

```bash
# 检查数据文件是否存在
ls -la SNP-disease/

# 手动运行导入脚本
docker compose exec backend python import_data.py --file /data/snp-disease/variant_sad_all_targets.tsv --batch-size 1000
```

## 生产环境建议

### 1. 修改默认密码

修改 `docker-compose.yml` 中的数据库密码：

```yaml
environment:
  POSTGRES_USER: cattle_user
  POSTGRES_PASSWORD: <your-strong-password>
  POSTGRES_DB: cattle_snp_db
```

同时更新后端的 `DATABASE_URL`：

```yaml
environment:
  DATABASE_URL: postgresql://cattle_user:<your-strong-password>@db:5432/cattle_snp_db
```

### 2. 配置 HTTPS

使用 Nginx 反向代理和 Let's Encrypt：

```bash
# 安装 certbot
sudo apt install certbot python3-certbot-nginx

# 获取证书
sudo certbot --nginx -d your-domain.com
```

### 3. 设置自动重启

已配置 `restart: unless-stopped`，服务会随 Docker 自动启动。

### 4. 定期备份

创建定时任务：

```bash
# 编辑 crontab
crontab -e

# 每天凌晨 2 点备份
0 2 * * * cd /opt/cattleVarDB && docker exec cattle_var_db pg_dump -U cattle_user cattle_snp_db | gzip > backup_$(date +\%Y\%m\%d).sql.gz

# 保留最近 7 天的备份
0 3 * * * find /opt/cattleVarDB -name "backup_*.sql.gz" -mtime +7 -delete
```

### 5. 监控服务健康

```bash
# 创建健康检查脚本
cat > healthcheck.sh << 'EOF'
#!/bin/bash
curl -f http://localhost/health || exit 1
EOF

chmod +x healthcheck.sh

# 添加到 crontab，每 5 分钟检查一次
*/5 * * * * /opt/cattleVarDB/healthcheck.sh
```
